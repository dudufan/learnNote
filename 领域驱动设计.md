# 领域模型

## 作用

- 作为业务专家、开发人员、测试沟通的通用语言
- 模型是浓缩的知识。通过类和行为清楚的表达场景，深入描述业务。
- 获取程序设计的术语，程序代码是模型的表达

不断消化知识提炼模型，重要的概念被加入模型，不重要的去掉

## 交流

主要以非正式UML的类图和对象交互图为主，保持简洁避免过于细致。

图和文档解释核心要点，设计的重要细节应该在代码里体现。

> 简洁的小图便于沟通，涵盖整个对象模型的综合性大图反而失去了沟通或解释能力。

## 运用模型

应该反复修改模型，真正的绑定实现，否则两者会相去甚远。比如PCB布局软件bus的例子，软件没有bus模型的支持工程师只能自定义脚本实现bus的功能。

目标：

- 软件更自然的实现模型，用代码表达模型
- 每个开发人员都必须用该领域通用语言（Ubiquitous Language)反馈和讨论模型，及时交换想法
- 模型反映出更深层次的领域概念

## 分离领域

分离领域是领域驱动设计的前提。

分层架构：

1. 用户界面层
2. 应用层。协调领域层完成工作。不反应业务的状态，可以有另一种状态，显示用户或某个任务的进度
3. 领域层。负责基本业务规则。比如网银转账的业务规则是“每笔贷款必须有与其数目相同的借款”。但保存业务状态是在基础设施层。
4. 基础设施层。一般以service方式提供，为上面各层提供通用的技术能力：为应用层传递消息，为领域层持久化，为用户界面绘制屏幕组件，架构框架提供4个层间的交互模式等等

各层关联相互连接，比如MVC模式。保证领域层不用考虑用户交互

smart UI模式类似React，用户界面中嵌入业务规则。领域驱动设计把它看做是分层架构的反模式。

# 领域建模

简化关联的方法：

1. 规定一个遍历方向（关联方向）。国家和总统的关联规定为，国家到总统的单向关联。
2. 添加一个限定符，以便有效减少多重关联（一对多简化为一对一）。比如国家有多位总统 => 国家在一个period只有一位总统
3. 消除不必要的关联

## Entity

Entity：

1. 由标识定义的对象。模型必须定义出“符合什么条件才算是相同的事物”。
2. 最基本的职责是确保连续性，以便使其行为清晰可预测
3. 生命周期内属性可能变化

举例：体育场座位预订程序可能会将座位和观众当作Entity来处理。分配座位时，每张票有一个座位号，座位是Entity，其标识是座位号，在体育场中唯一。

如果活动采用赠送的入场券形式，观众可以选择任意空位来坐，这种情况下座位总数才重要。

Entity也可以有多组标识，类似唯一约束。如果一个Customer有很多个phone number，那么phone number应该被放到Sales Contact里（一个Customer可以有多个Sales Contact）

**标识生成**
系统内生成的id，不能和其他系统交互信息，因为无法确定是同一个Entity。

一般用户提供外部id作为标识，如手机号注册，使用其他属性进行匹配和验证（验证码、身份证号）。



## Value Object

> 跟踪Entity的标识非常重要，但为其他对象加上标识会增加系统复杂性

Value Object可以是其他Value Object或Entity的集合。比如墙由窗户、砖等组成，路线由两个城市(Entity)和沿途景点、G210国道组成。

Value Object包含的属性应该形成一个概念整体，而不是单独的基本属性。如Person包含Address，Address包含street、city、state。

使用Value Object：

1. 复制。分布式、关系数据库中，冗余复制对象相当于空间换时间。访问时间比存储空间或维护的简单性更重要时，选择复制。
2. 共享。要求对象是不可变的，方便优化性能，调整设计。

Value Object之间不能有双向关联，因为没有意义。

## Service

领域层的Service：

1. 一些领域概念不适合被建模为对象，
2. 一般是无状态的，
3. 作为接口提供函数过程式的操作。
4. 强调与其他对象的关系，组织Entitys和Value Objects执行任务。比如资金转账service处理借贷双方的关系

注意区分领域层和其他层的service，划分责任

service模式的优点：

1. 可以保持接口的简单性

2. 便于客户端控制并提供多样化的功能

3. 中等粒度的无状态的service容易被复用

4. 有时service是表示领域概念最自然的方式

   



## 面向对象

领域建模的主流范式是面向对象技术。也可以使用其他范式和技术对特殊概念建模，比如业务规则引擎、工作流引擎、关系型数据库这样的非对象组件

需要对非对象范式的部分进行封装，集成到对象范式的模型中去

个人理解orm框架就是把非对象范式的数据库衔接到了对象范式中去。

## AGGREGATE

AGGREGATE定义了对象的生命周期（Scope）。

背景：

- 多个对象需要遵守一些固定规则，但具有复杂关联的模型难以保持对象更改的一致性。
- 过于谨慎的锁定机制又会导致多个用户间无意义的干扰，甚至死锁。

**AGGREGATE**是一组对象的集合。特点：

- 每个AGGREGATE都有一个根和一个边界。
- root是AGGREGATE所包含的一个特定Entity
- 边界定义了AGGREGATE内部有什么
- 

作用：

1. 明确定义模型对象的边界
2. 减少设计中的关联。

使问AGGREGATE的方式：

- 外部的对象只能引用root
- 边界内部的对象间可以互相引用
- root具有全局标识，root以外的其他Entity都有内部唯一标识
- 对内部成员的临时引用可以被传递出去，不能被外部对象保存
- 推论：只有root才能直接通过数据库查询获取，其他对象通过遍历关联来发现

举例，汽修厂使用的汽车模型：

- root是Car，Car具有唯一的车辆识别号。
- 我们想知道每个wheel的胎压、里程数和磨损程度，必须标识为Entity，但wheel脱离Car后成为废旧轮胎，不再关心它的标识。
- 不会有人通过系统查询特定的wheel（不会绕过root直接访问）
- 发动机有独立序列号，它可以是自己的AGGREGATE。它在Car所在AGGREGATE之外

**Purchase Order订单示例**

PO(approved limit) -->* PO Line Item(quantity) --> Part(price)

- 该模型未说明删除PO如何影响PO、Part
- 对同一订单并发修改不同商品金额，导致超出PO审批限额，因此需要锁定该PO。

- Part是商品信息的模型对象，多种商品被多个订单引用，也可以被多个用户修改。订单价格是Part最新的还是下单时的价格？这个业务规则应该体现在模型里

优化后的PO模型

 【PO(approved limit)  聚合-->* PO Line Item(quantity, price) 】--> Part(price)

- AGGREGATE强制了PO与采购项之间的业务规则
- 把PO和 PO Line Item作为一个AGGREGATE,而Part的创建和删除却是独立的。

## 关联

双向关联有时是必要的。

举例物流追踪软件中：

- Cargo(货物)、Location（位置）、Carrier Movement(货物旅程)、Customer（客户）都是AGGREGATE
- Handing Event（处理事件）是AGGREGATE。因为处理Cargo的活动可以与Cargo分开考虑，比如单独录入处理事件日志。



双向关联：Cargo 1---1 Delivery History（运送历史）

解释：Cargo有Delivery History。此程序的核心是对Cargo跟踪，因此Delivery History也必须引用Cargo



循环引用：

- Handing Event  --- handled --> Cargo(货物)
- Cargo --- Delivery History -->*  Handing Event

解决办法：Handing Event的Repository增加后，Delivery History中不使用 Handing Event的集合。而是用一个查询代替，查询与特定Cargo有关的Event



## Factory

复杂对象（AGGREGATE）需要Factory来创建。原因：

1. 不能让自身创建自己。类似机械师、工业机器人来装配发动机，避免职责混乱
2. 客户代码创建又会破坏封装，依赖了实现。

Factory应该只被关联到与被构建对象有这密切联系的对象上：

1. 向已存在的AGGREGATE中添加元素，可以在root上创建一个factory method，如newItem()
2. 通常一个独立的Factory创建整个AGGREGATE，确保它满足固定规则。

以下情况直接使用构造函数创建：

- 构造并不复杂，无嵌套对象
- 该class表示type，没有层次体系

## Repository

职责：

- 根据标识或属性全局检索重建已存储对象，一般是AGGREGATE的root Entity。
- Repository对象相当于该Entity所有对象在内存中集合的一个“替身”，封装了实际存储和查询技术

> value object一般通过遍历某个Entity来找到，如果需要在数据库搜索一个已存在的value，那值得考虑它可能实际上是一个Entity，只是尚未识别它的标识。

需要注意几点：

- 开发人员需要关注Repository的实现，比如性能、内存占用
- Repository能查询的可能类型可以是基类、接口、具体的类
- 事务控制权给客户
- 当数据库被视作对象存储时，数据模型与对象模型的差别不应太大。对象模型的重构可能导致和数据库模型的背离。

多数情况下关系数据库设计与模型是简单的对应关系：

- 表中的一行应包含一个对象，也可能包含AGGREGATE的一些附属项
- 表中的外键应转换为对另一个Entity对象的引用
- 有时局部可以违背这种简单的对应关系



## 总结

模型设计精化过程：

- 隔离领域，引入应用层
- 区分Entity和Value Object
- 设计关联
- 确定AGGREGATE边界
- 选择Repository
- 设计对象创建方式，包括Factory和构造函数
- 重构：重新设计AGGREGATE、简化关联
- 按领域概念划分module
- 系统间交互引入中间层，它也反映领域概念

# 重构

一个运输应用系统的无用模型：

- 货轮（ship)负责运送货物从一个地点到另一个地点

- 集装箱通过装卸操作关联货轮或解除关联。

重构后：

- 保留ship，抽象为”船只航次“，即运输工具的某一调度好的航程

- 集装箱从模型中移除
- 更关注法律责任的转移

- 加入提货单等对象